1. a0-a7 存放函数的参数。13放在a2。a0既用来当存放函数调用时候的参数，也用来放return的值。

2. 编译的时候已经跳过了函数调用，直接拿到了结果：12

3.  auipc   ra,0x0 # 把pc里的地址加上0x0<<12。结果为0x30，存入ra
    jalr    1536(ra)
    auipc 是用来找pc-relative地址，
    printf的地址是630

4.  放的0x38，jalr跳转过后，会将pc+4的值放进ra。

5.  57616=0xE110，0x00646c72小端存储为72-6c-64-00，对照ASCII码表
    72:r 6c:l 64:d 00:充当字符串结尾标识
    因此输出为：HE110 World
    若为大端存储，i应改为0x726c6400，不需改变57616
    unsigned int i = 0x00646c72;
    printf("%s", &i);  &i 并不是去把646c72当作地址号码，
    而是代表`变量i`的地址，地址指向的内存位置，存放着646c72这个数字

6.  原本需要两个参数，却只传入了一个，因此y=后面打印的结果取决于之前a2中保存的数据
    printf("%d %d\n", f(8)+1, 13);
    a1 放12， a2放13，a0放的字符串"%d %d\n"